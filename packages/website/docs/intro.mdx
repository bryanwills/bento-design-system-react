---
sidebar_position: 1
---

import { PackageManagerCommand } from "@site/src/components/PackageManagerCommand";

# Welcome to Bento Design System

Bento is a configurable and extensible Design System for React.

It is s meant to be used as a foundation for your project's Design System.

## Quick start

First, add the Bento package to your project:

<PackageManagerCommand
  command={{
    pnpm: "add @buildo/bento-design-system",
    yarn: "add @buildo/bento-design-system",
    npm: "install @buildo/bento-design-system",
  }}
/>

Then, let's import the Bento stylesheet. We are also going to import Bento's default theme, so that we can get started right away.
(Don't worry, we will discuss later how to create your own custom theme):

```ts title="my-project/design-system/src/index.tsx"
import "@buildo/bento-design-system/lib/index.css";
import "@buildo/bento-design-system/lib/defaultTheme.css";
```

Now we can use `createBentoComponents` to create and exports the components we need, for example

```tsx title="my-project/design-system/src/index.tsx"
import "@buildo/bento-design-system/lib/index.css";
import "@buildo/bento-design-system/lib/defaultTheme.css";

// highlight-start
export const {
  Banner,
  Button,
  CheckboxField,
  Chip,
  RadioGroupField,
  SelectField,
  TextField,
  Title,
  DesignSystemProvider,
} = createBentoComponents();
// highlight-end
```

The `DesignSystemProvider`, returned alongside the other components by `createBentoComponents`, is a React context provider that is required for some components to work.
You need to wrap your entire application with it in order to use Bento components.

`DesignSystemProvider` has a required `defaultMessages` parameter: this is used to provide standard localized messages for some components.

<details>
  <summary>Why using default messages?</summary>

Bento components are entirely agnostic when it comes to localization: all components accept the
text to be display to the user as props.

Some specific props, however, are very repetitive and would be too tedious to pass them as props
every time you use the component. Think of messages like `"No options"` when a `SelectField` or
accessibility labels like "Close", which are used to describe actions on icons.

Without the default messages, for example, you would need to pass `dismissButtonLabel` every time you use `Chip`:

```tsx
<Chip label={label} color={color} dismissButtonLabel={dismissButtonLabel} />
```

whereas default messages allow Bento to make `dismissButtonLabel` optional, and let you override it only if needed:

```tsx
// This uses the default message for `dismissButtonLabel`
<Chip label={label} color={color} />

// This overrides the default message
<Chip label={label} color={color} dismissButtonLabel={myCustomDismissLabel} />
```

</details>

```tsx title="my-project/app/src/App.tsx"
import { DesignSystemProvider, Title } from "design-system";
import { defaultMessages } from "./defaultMessages";

<DesignSystemProvider defaultMessages={defaultMessages}>
  <Title size="large">Hello, World!</Title>
</DesignSystemProvider>;
```

<details>
  <summary>Here's some sample default messages you can use to get started:</summary>

```tsx title="my-project/app/src/defaultMessages.tsx"
import { ComponentProps } from "react";
import { DesignSystemProvider } from "design-system";

// This is a mocked implementation of a localization function, to get you started.
// In a real application it will be replaced by a real one, like `react-i18next` or `react-intl`.
// Bento requires to cast the strings that are localized as `LocalizedString`: we will discuss this
// shortly.
const formatMessage = (x: string) => x as any;

export const defaultMessages: ComponentProps<typeof DesignSystemProvider>["defaultMessages"] = {
  Chip: {
    dismissButtonLabel: formatMessage("Remove"),
  },
  Banner: {
    dismissButtonLabel: formatMessage("Close"),
  },
  Modal: {
    closeButtonLabel: formatMessage("Close"),
  },
  SelectField: {
    noOptionsMessage: formatMessage("No options"),
    multiOptionsSelected: (n) => {
      const options = n > 1 ? "options" : "option";
      return formatMessage(`${n} ${options} selected`);
    },
  },
  SearchBar: {
    clearButtonLabel: formatMessage("Clear"),
  },
  Table: {
    noResultsTitle: formatMessage("No results found"),
    noResultsDescription: formatMessage(
      "Try adjusting your search filters to find what you're looking for."
    ),
    missingValue: formatMessage("-"),
  },
  Loader: {
    loadingMessage: formatMessage("Loading..."),
  },
};
```

</details>

:::note

In the examples above, we are assuming your project will use a workspace containing (at least) two packages:

- `design-system`
- `app`

where `app` depends on `design-system` locally (using the workspace feature by npm, pnpm or yarn).

We recommend this approach as it clearly separates the concerns, but nothing prevents from
co-locating design system and app components in the same project.

:::

## Customization

At this point, we got a set of components with a default configuration and theme.
However, Bento components are designed to be customized to your project's needs.
You can configure the Bento components in different ways:

- **theming:** Bento components are designed on top of a set of semantic design tokens, defining colors, spacings, typography, etc. These tokens consist in a set of CSS variables, which you can value as you wish to change the general look&feel of your app.
- **configuration:** Each component offers a variety of configurations you can set to change its basic anspect and behavior. You can both pass your configurations to `createBentoComponents`, or use component-specific constructors, like `createButtons`. By using component-specific constructors, you can also create different variants of the same component, to be used in different parts of your app.
- **atoms augmentation:** Bento has been built following the principles of [Atomic CSS](sprinkles-setup.md), and for this reason it defines a set of single-purpose CSS classes which, besides being used internally, can be used when building new project-specific components. In addition to this, Bento allows you to extend the set of atoms that are used to pre-generate these atomic classes, so that you can add even more design tokens and classes to meet your project's requirements. This process goes through the use of [Vanilla Extract](https://vanilla-extract.style/), a type-safe CSS preprocessor that generates CSS classes from TypeScript files and that's been used internally to create all the Bento components.

## Setting up Vanilla Extract

Before moving forward, let's setup Vanilla Extract in your project, so that it can process your .css.ts files.

Vanilla Extract supports several popular bundlers, but for a design system package we recommend using [tsup](https://tsup.egoist.sh/), which is especially well-suited for TypeScript libraries.

Here's a possible setup using to get you started:

<PackageManagerCommand
  command={{
    pnpm: "add -D tsup @vanilla-extract/esbuild-plugin",
    yarn: "add -D tsup @vanilla-extract/esbuild-plugin",
    npm: "install -D tsup @vanilla-extract/esbuild-plugin",
  }}
/>

Create a file named `tsup.config.ts` in your project root:

```ts
import { defineConfig } from "tsup";
import { vanillaExtractPlugin } from "@vanilla-extract/esbuild-plugin";

export default defineConfig({
  entry: ["src/index.ts"],
  outDir: "lib",
  esbuildPlugins: [vanillaExtractPlugin()],
  dts: true,
  // See https://esbuild.github.io/content-types/#auto-import-for-jsx
  inject: ["./jsxShim.ts"],
});
```

And a file named `jsxShim.ts` in your project root:

```ts
// See https://esbuild.github.io/content-types/#auto-import-for-jsx
import * as React from "react";
export { React };
```

Done! Now you can add two scripts to your `package.json`:

```json
"scripts": {
  "build": "tsup --minify --clean",
  "watch": "tsup --watch",
}
```

Ok, now that we got the build stuff out of the way, let's continue with more interesting things!
