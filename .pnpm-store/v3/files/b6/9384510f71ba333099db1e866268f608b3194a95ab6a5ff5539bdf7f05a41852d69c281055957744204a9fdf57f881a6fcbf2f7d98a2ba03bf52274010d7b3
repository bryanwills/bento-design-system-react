"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortExportAll = void 0;
const natural_compare_1 = __importDefault(require("natural-compare"));
const isValidOrders = {
    asc(a, b) {
        return a <= b;
    },
    ascI(a, b) {
        return a.toLowerCase() <= b.toLowerCase();
    },
    ascN(a, b) {
        return (0, natural_compare_1.default)(a, b) <= 0;
    },
    ascIN(a, b) {
        return (0, natural_compare_1.default)(a.toLowerCase(), b.toLowerCase()) <= 0;
    },
    desc(a, b) {
        return isValidOrders.asc(b, a);
    },
    descI(a, b) {
        return isValidOrders.ascI(b, a);
    },
    descN(a, b) {
        return isValidOrders.ascN(b, a);
    },
    descIN(a, b) {
        return isValidOrders.ascIN(b, a);
    },
};
exports.sortExportAll = {
    meta: {
        type: "suggestion",
        fixable: "code",
        docs: {
            description: "require export * to be sorted",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://github.com/nirtamir2/eslint-plugin-sort-export-all",
        },
        schema: [
            {
                enum: ["asc", "desc"],
            },
            {
                type: "object",
                properties: {
                    caseSensitive: {
                        type: "boolean",
                    },
                    natural: {
                        type: "boolean",
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create: (context) => {
        const order = context.options[0] === "desc" ? "desc" : "asc";
        const options = context.options[1];
        const insensitive = (options && options.caseSensitive) === false;
        const natural = Boolean(options && options.natural);
        const functionName = (order +
            (insensitive ? "I" : "") +
            (natural ? "N" : ""));
        const isValidOrder = isValidOrders[functionName];
        if (isValidOrder === null) {
            throw new Error("Invalid options");
        }
        let prevNode = null;
        return {
            ExportAllDeclaration: (node) => {
                if (node.type !== "ExportAllDeclaration") {
                    return;
                }
                if (prevNode != null &&
                    typeof node.source.value === "string" &&
                    typeof prevNode.source.value === "string") {
                    const thisName = node.source.value;
                    const prevName = prevNode.source.value;
                    if (isValidOrder(thisName, prevName)) {
                        context.report(Object.assign(Object.assign({ message: "\"export * from '{{thisName}}'\" should occur before \"export * from '{{prevName}}'\".", node }, (node.loc === null ? null : { loc: node.loc })), { data: {
                                thisName,
                                prevName,
                            }, fix(fixer) {
                                if (prevNode == null)
                                    return null;
                                const fixes = [];
                                const sourceCode = context.getSourceCode();
                                const moveExportAllDeclaration = (fromNode, toNode) => {
                                    const prevText = sourceCode.getText(fromNode);
                                    const thisComments = sourceCode.getCommentsBefore(fromNode);
                                    for (const thisComment of thisComments) {
                                        fixes.push(fixer.insertTextBefore(toNode, 
                                        // @ts-ignore
                                        `${sourceCode.getText(thisComment)}\n`));
                                        // @ts-ignore
                                        fixes.push(fixer.remove(thisComment));
                                    }
                                    fixes.push(fixer.replaceText(toNode, prevText));
                                };
                                moveExportAllDeclaration(node, prevNode);
                                moveExportAllDeclaration(prevNode, node);
                                return fixes;
                            } }));
                    }
                }
                prevNode = node;
            },
        };
    },
};
//# sourceMappingURL=sort-export-all.js.map